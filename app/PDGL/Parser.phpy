// vim: syntax=yacc noexpandtab

%pure_parser
%expect 6

%token T_FINAL
%token T_CLASS
%token T_EXTENDS
%token T_IMPLEMENTS
%token T_DIRECT
%token T_VAL
%token T_VAR

%token T_TRIPLE_BACKQUOTE
%token T_COLON_ASSIGN
%token T_ARROW_ASSIGN

%token T_LITERAL
%token T_NUMBER

%token T_STRING_SQ
%token T_STRING_DQ

%%

file
	: file_stmts
	;

file_stmts
	: file_stmt				{ $$ = [$1]; }
	| file_stmts file_stmt	{ $$ = array_merge($1, [$2]); }
	|						{ $$ = []; }
	;

file_stmt
	: class
	;

class
	: class_mods T_CLASS T_LITERAL class_ext_impls '{' class_stmts '}'
		{
            $$ = new Model\Class_([
                'name' => $3,

                'data'       => ($1 & 4) !== 0,
                'final'      => ($1 & 1) !== 0,
                'finalFinal' => ($1 & 2) !== 0,

                'extends'    => $4['extends'],
                'implements' => $4['implements'],

                'fields' => $6
            ]);
		}
	;

class_mods
	:				{ $$ = 0; }
	| T_FINAL		{ $$ = 1; }
	| T_FINAL '!'	{ $$ = 3; }
	;

class_ext_impls
	: class_extends class_implements	{ $$ = ['extends' => $1, 'implements' => $2]; }
	| class_implements class_extends	{ $$ = ['extends' => $2, 'implements' => $1]; }
	;

class_extends
	:						{ $$ = null; }
	| T_EXTENDS class_name	{ $$ = $2; }
	;

class_implements
	:								{ $$ = []; }
	| T_IMPLEMENTS class_names_list	{ $$ = $2; }
	;

class_name
	: T_LITERAL
	| '\\' T_LITERAL
	| class_name '\\' T_LITERAL
	;

class_names_list
	: class_name						{ $$ = [$1]; }
	| class_names_list ',' class_name	{ $$ = array_merge($1, [$3]); }
	;

class_stmts
	:							{ $$ = []; }
	| class_stmt				{ $$ = [$1]; }
	| class_stmts class_stmt	{ $$ = array_merge($1, [$2]); }
	;

class_stmt
	: field
	;

field
	: field_mods field_keyword T_LITERAL field_type field_defval ';'
		{
            $$ = new Model\Field([
                'name' => $3,

                'editable' => $2,
                'direct'   => ($1 & 1) !== 0,

                'type' => $4,

                'directDefining' => ($5['assign'] & 2) !== 0,
                'filterDefault'  => ($5['assign'] & 1) !== 0,
                'default'        => $this->parseDefval($5['value'])
            ]);
		}
	;

field_mods
	:			{ $$ = 0; }
	| T_DIRECT	{ $$ = 1; }
	;

field_keyword
	: T_VAL	{ $$ = false; }
	| T_VAR	{ $$ = true; }
	;

field_type
	:						{ $$ = new Type('mixed', false); }
	| ':' field_typename	{ $$ = $2; }
	;

field_typename
	: class_name		{ $$ = new Type($1, false); }
	| class_name '?'	{ $$ = new Type($1, true); }
	;

field_defval
	:	{ $$ = ['assign' => 1, 'value' => null]; }

	| assign field_defval_contents
		{
            $$ = [
                'assign' => $1,
                'value'  => $2,
            ];
		}
	;

/* Assign
 *
 * 1st bit - filter default
 * 2nd bit - direct defining
 *
 */
assign
	: '='				{ $$ = 1; }
	| T_COLON_ASSIGN	{ $$ = 0; }
	| T_ARROW_ASSIGN	{ $$ = 2; }
	;

field_defval_contents
	: php_expr											{ $$ = $1; }
	| '`' php_expr '`'									{ $$ = $2; }
	| T_TRIPLE_BACKQUOTE php_expr T_TRIPLE_BACKQUOTE	{ $$ = $2; }
	;

php_expr
	: T_LITERAL
	| '$' T_LITERAL
	| php_expr php_expr
	| class_name
	| '(' php_expr ')'
	| php_expr '='
	| '=' php_expr
	| '&' php_expr
	| php_expr '+'
	| php_expr '-'
	| php_expr '*'
	| php_expr '/'
	| php_expr '.'
	| php_expr '%'
	| php_expr '&'
	| php_expr '|'
	| php_expr '^'
	| php_expr '<' '<'
	| php_expr '>' '>'
	| php_expr '*' '*'
	| php_expr '+' '+'
	| php_expr '-' '-'
	| '+' '+' php_expr
	| '-' '-' php_expr
	| php_expr '|' '|'
	| php_expr '&' '&'
	| '+' php_expr
	| '-' php_expr
	| '!' php_expr
	| '~' php_expr
	| php_expr '=' '=' '='
	| php_expr '!' '=' '='
	| php_expr '=' '='
	| php_expr '!' '='
	| php_expr '<' '=' '>'
	| php_expr '<'
	| php_expr '<' '='
	| php_expr '>'
	| php_expr '>' '='
	| '@' php_expr
	| php_expr ':' ':'
	| '[' php_expr ']'
	| '`' php_expr '`'
	| '{' php_expr '}'
	| T_NUMBER
	| T_STRING_SQ
	| php_string_dq
	;

php_string_dq
	: T_STRING_DQ
	| php_string_dq T_STRING_DQ
	;

%%

    public function parseDefval(string $value): Node\Expr {
        static $parser = null;

        if (is_null($parser)) {
            $parser = (new ParserFactory())->create(ParserFactory::ONLY_PHP7);
        }

        return $parser->parse("<?php $value;")[0]->expr;
    }
